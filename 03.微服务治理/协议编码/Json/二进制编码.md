# 二进制编码

对于仅在组织内部使用的数据，使用最小公分母编码格式的压力较小。例如，可以选择更紧凑或更快的解析格式。虽然对小数据集来说，收益可以忽略不计，但一旦达到 TB 级别，数据格式的选择就会产生巨大的影响。

JSON 比 XML 简洁，但与二进制格式一比，还是太占地方。这一事实导致大量二进制编码版本 JSON & XML 的出现，JSON（MessagePack，BSON，BJSON，UBJSON，BISON 和 Smile 等）（例如 WBXML 和 Fast Infoset）。这些格式已经被各种各样的领域所采用，但是没有一个像 JSON 和 XML 的文本版本那样被广泛采用。

这些格式中的一些扩展了一组数据类型（例如，区分整数和浮点数，或者增加对二进制字符串的支持），另一方面，它们没有盖面 JSON / XML 的数据模型。特别是由于它们没有规定模式，所以它们需要在编码数据中包含所有的对象字段名称。也就是说，在下例中的 JSON 文档的二进制编码中，需要在某处包含字符串 userName，favoriteNumber 和 interest。

```json
{
  "userName": "Martin",
  "favoriteNumber": 1337,
  "interests": ["daydreaming", "hacking"]
}
```

我们来看一个 MessagePack 的例子，它是一个 JSON 的二进制编码。下图显示了如果使用 MessagePack 对上例中的 JSON 文档进行编码，则得到的字节序列。前几个字节如下：

1. 一个字节`0x83`表示接下来是**3**个字段（低四位= `0x03`）的**对象 object**（高四位= `0x80`）（如果想知道如果一个对象有 15 个以上的字段会发生什么情况，字段的数量塞不进 4 个 bit 里，那么它会用另一个不同的类型标识符，字段的数量被编码两个或四个字节）。
2. 第二个字节`0xa8`表示接下来是**8**字节长的字符串（最高四位= 0x08）。
3. 接下来八个字节是 ASCII 字符串形式的字段名称`userName`。由于之前已经指明长度，不需要任何标记来标识字符串的结束位置（或者任何转义）。
4. 接下来的七个字节对前缀为`0xa6`的六个字母的字符串值`Martin`进行编码，依此类推。

二进制编码长度为 66 个字节，仅略小于文本 JSON 编码所取的 81 个字节（删除了空白）。所有的 JSON 的二进制编码在这方面是相似的。空间节省了一丁点（以及解析加速）是否能弥补可读性的损失，谁也说不准。

![使用MessagePack编码的记录](https://s2.ax1x.com/2020/02/06/1yWWAs.md.png)
