> [原文地址](https://xie.infoq.cn/article/cda63364ce7f241631d9730c0)

# 一文简述：云原生架构的四个特征六个原则

云原生应用程序构建为在 Docker 容器中运行的一组微服务，在 Kubernetes 中编排，并使用 DevOps 和 Git Ops 工作流进行部署和管理。使用 Docker 容器的优点是能够将执行所需的所有软件打包到一个可执行包中。容器在虚拟化环境中运行，从而将包含的应用程序与其环境隔离。云原生架构是一种包含技术实现与管理（组织流程）的软件开发方法论。技术实现部分主要包括敏捷基础设施、云公共基础服务和微服务；组织流程部分主要包括持续交付和 DevOps。云原生应用架构包含 3 个特征：容器化、微服务和 DevOps。

![云原生架构](https://static001.geekbang.org/infoq/98/98f40fd7da55dffb96543921401c1939.png)

#### 四个特征

##### 1. 敏捷基础设施

可编程式基础设施作为云原生应用的底座主要为了解决传统基础设施所面临的挑战，包括资源利用率低、资源扩容周期长、节点数量暴增、缺乏标准化。也意味着开发人员可以更频繁地构建更强可控或更稳定的基础设施，无须运维人员参与，开发人员可以随时拉取一套基础设施来服务于开发、测试、联调和灰度上线等需求。

##### 2. 微服务

微服务架构是云原生架构的核心构成。微服务将大型复杂软件应用拆分成多个简单应用，每个简单应用描述一个小业务，系统中的各个简单应用可以被独立部署，各个应用之间是松耦合的，每个应用仅关注完成一件任务并很好地完成该任务。相比传统的单体架构，微服务架构具有降低系统复杂度、独立部署、独立扩展、跨语言编程等特点。

使用微服务也会带来很多问题，比如性能延迟、数据一致性、集成测试、故障诊断等。企业需要根据业务的不同阶段进行合理的引入，不能完全为了微服务而“微服务”。

服务网格是一种非侵入式架构，负责应用之间的网络调用、限流、熔断和监控，可以保证应用的调用请求在复杂的微服务应用拓扑中可靠地穿梭。服务网格通常由一系列轻量级的网络代理组成（通常被称为 SideCar 模式），与应用程序部署在一起，但应用程序不需要知道它们的存在。服务网格通过服务发现、路由、负载均衡、健康检查和可观察性来帮助管理流量。

##### 3. 持续交付

持续交付代表一种软件交付的能力，打通开发、测试、生产的各个环节，自动持续、增量地交付产品，以达到随时都能发布的能力，涉及一系列的开发实践方法。持续交付分为持续集成、持续部署、持续发布等阶段。

持续交付关注“从提交代码到产品发布”的过程，随着某个构建逐步通过每个测试阶段，代码的质量一步步得以验证。当然，我们在每个阶段中对环境方面的资源投入也在不断增加，即越往后的阶段，其环境与生产环境越相似。为了获得健康良性的持续交付效果，我们要坚持少做多验证、持续分解问题、坚持快速反馈、持续改进并衡量。

##### 4. DevOps

DevOps 提倡通过一系列的技术和工具减少开发和运维之间的隔阂，实现从开发、构建到最终部署的全流程自动化，从而达到开发运维一体化。DevOps 是一套实践方法，在保证高质量的前提下缩短系统变更从提交到部署至生产环境的时间。DevOps 强调的是高效组织团队之间如何通过自动化的工具协作和沟通来完成软件的生命周期管理，从而更快、更频繁地交付更稳定的软件。

持续集成是指在软件开发过程中，软件开发人员持续不断地将开发出来的代码和其他开发人员的代码进行合并，每次合并后自动进行编译、构建，并运行自动化测试进行验证，而不是等到最后各自开发完成后才合并在一起。持续集成能从根本上提高一个团队的软件开发效率。

一个 DevOps 开发环境需要满足以下 8 点要求：环境一致性、代码自动检查、持续集成、持续部署、持续反馈、快速回滚、弹性伸缩、可视化运维。

![DevOps 开发环境](https://static001.geekbang.org/infoq/ba/bafc22d1faab5c2698e2359e227e5e4d.png)

整个环境主要由以下 6 个部分组成：代码仓库 GitLab、容器技术 Docker、持续集成工具 Jenkins、代码质量检测平台 SonarQube、镜像仓库 Harbor、容器集群管理系统 Kubernetes。

#### 六个原则

云原生是面向“云”而设计的应用，但要给云原生下一个明确的定义很难，所有的架构的目标都是解决特定的业务场景。那么在云原生落地的时候可以遵循哪些原则，才能更好地服务于业务发展。

##### 1. 去中心化原则

中心化意味着单点，为了具备良好的线性扩展能力，分布式系统要求去中心化，避免单点故障。微服务架构虽然也有一个服务注册中心，但服务注册中心只负责应用启动或者状态变更时做服务推送，真正在运行过程中微服务之间的相互调用都是点对点直接调用，即运行时是去中心化的。

云原生对开发团队一个很重要的要求是独立自主，每个服务由独立的团队负责开发运维，所有者的团队对服务具有决策权，可以自主选择技术栈以及研发进度，服务之间只要接口不变，外部就不必对其过度关注，更容易实现关注点分离。

##### 2. 松耦合原则

服务消费端不需要依赖服务契约的某个特定实现，这样服务提供端的内部变更就不会影响消费端，而且消费端未来还可以自由切换到该契约的其他服务提供方。其中包括时间的耦合、位置的耦合、版本的耦合等等。

##### 3. 失败设计原则

所有的外部调用都有容错处理，我们希望失败的结果是我们可预期的、经过设计的。在微服务架构场景中，当服务数量越来越多，依赖越来越复杂时，出现问题的概率也就越大，问题定位也会越来越困难，这时再用传统的解决办法将是一个灾难。

应充分考虑异常情况，从使用者的角度出发，能够容忍故障的发生，最小化故障的影响范围。系统架构设计时需要考虑到应用系统的每一个层面，包括硬件和软件是可能出现故障的，并据此在应用系统架构设计上消除单一故障点。

##### 4. 无状态化原则

服务在处理请求时，不依赖除请求本身以外的其他内容，也不会有除响应请求之外的额外操作。这样如果要实现无状态服务的并行横向扩展，只需要对服务节点进行并行扩展，在服务之上添加一个负载均衡。

云原生的应用服务设计尽可能是无状态的，使得业务天生具有扩展性，在业务流量高峰和低峰时期，依赖云的特性自动弹性扩容、缩容，满足业务需求。

##### 5. 不变性原则

基础设施中的每个服务、组件都可以自动安装、部署，不需要人工干预。所有的资源都可以随时拉起、随时释放，同时以 API 的方式提供弹性、按需的计算、存储能力。每个服务或者组件在安装部署完成后将不会发生更改，如果要更改，就丢弃老的服务或组件，并重新部署一个服务或组件。另外，为了提升可用性，我们应该尽量减少故障修复时间，要知道替换的速度远远快于修复的速度。

##### 6. 自动化驱动原则

自动化驱动分为持续集成、持续部署、持续交付等阶段，用来确保需求的提出、设计开发测试，再到代码快速、安全地部署到生产环境中。

当提交代码后，自动化的工具链自动编译、构建、测试、集成。开发人员持续优化代码，当满足上线要求时，自动化部署到生产环境中。这种自动化的方式能够实现更可靠的操作，既避免了人为失误，又避免了微服务数量增多带来的开发、运维、管理的复杂化。
