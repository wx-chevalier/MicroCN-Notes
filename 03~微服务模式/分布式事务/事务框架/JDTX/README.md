# JDTX

JDTX 的设计目标是强一致（支持 ACID 的事务原义）、高性能（甚至强于本地事务）、1PC（完全摒弃两阶段提交和两阶段锁）的完全分布式事务中间件，目前可用于关系型数据库。它采用完全开放 SPI 的设计方式，提供与 NoSQL 对接的可能，能够将多元异构数据维持在同一事务中。

# 设计理念

首先通过一张架构图来直观的了解一下 JDTX 的构成。

![JDTX 架构](https://s2.ax1x.com/2019/10/26/K0jefO.png)

JDTX 由事务管理器（TM）和资源管理器（RM）组成。事务管理器用于生成全局单调递增的事务日志序列号（LSN），事务的提交和回滚等核心流程处理，以及未提交事务的本地元祖（Tuple）持有。资源管理器用于管理活跃事务数据。JDTX 的设计特点是将在事务中的数据（称之为活跃数据）和不在事务中的数据（称之为落盘数据）分离。活跃数据在落盘至预写日志系统（WAL）之后，并将数据保存至自研的多版本快照（MVCC）内存引擎中。落盘数据则是通过异步刷盘的方式，将 MVCC 引擎中的数据以流量可控的方式同步至最终的存储介质中（如：关系型数据库）。事务内查询会将落盘数据和活跃数据合并，并根据当前事务的隔离级别获取出符合当前事务可见性的数据版本。

# 方案亮点

## 无损事务方案

JDTX 采用 WAL + MVCC 引擎的方式实现了事务的 ACID 原义。

- 原子性 & 一致性支持：JDTX 的 MVCC 引擎可以看做是一个集中式缓存，可以将两阶段提交简化至一阶段提交。维持单一节点中数据的原子性和一致性，即将分布式事务的范畴缩减到本地事务的范畴。MVCC 引擎可以通过分片 + 主从同步的方式维持水平扩展和高可用的能力。JDTX 保证所有对事务数据的访问都通过 MVCC 引擎的活跃数据 + 最终数据端的落盘数据的合并的方式，以保证数据的原子性和一致性。

- 隔离性支持：JDTX 以多版本快照的方式实现事务隔离性。目前完整的支持 4 种标准隔离级别中的读已提交和可重复读，已经可以满足绝大部分需求。

- 持久性支持：JDTX 将事务的活跃数据在存入 MVCC 引擎之前先落盘至 WAL 引擎，以保证服务器崩溃，内存数据丢失时，活跃数据依然能够从 WAL 引擎中完全恢复。

## 高性能

JDTX 采用将活跃数据异步刷盘至数据库的方式极大的提高了数据写入的性能上限。它的性能瓶颈从数据库写入耗时转移到了落盘至 WAL 引擎和存储至 MVCC 引擎的耗时。

与数据库的 WAL 系统类似，JDTX 的 WAL 也采用日志顺序追加的方式，因此可以简单的理解为 JDTX 的 WAL 耗时 = 数据库系统的 WAL 耗时。而 MVCC 缓存则采用哈希数据结构，其写入耗时小于需要维护 BTree 索引的数据库写入耗时。因此，采用 JDTX 的事务方案，其数据更新性能甚至强于不开启事务。

另外，JDTX 采取了无 UNDO 日志的事务回滚策略。未提交的数据并不会进入 MVCC 引擎，而是被事务管理器本地持有。因此，只要清理掉未提交数据即可完成事务回滚。无 UNDO 日志的设计进一步的提升了事务处理的性能。

## 高可用

WAL 引擎和 MVCC 引擎均采用分片 + 主备的方式，以保证 JDTX 不会产生单点故障。在 MVCC 引擎完全不可用的情况下，可通过恢复模式将 WAL 中的数据同步至数据库，以保证数据的完整性。

## 跨多元数据库事务

JDTX 将事务活跃数据和落盘数据分离的设计方案，使其落盘数据存储端无任何限制。所有的事务活跃数据都会通过异步的落盘执行器存储至后端数据库，因此后端是否为同构数据库，其实并无影响。

使用 JDTX 能够保证跨多元存储端（如：MySQL、PostgreSQL 甚至是 MongoDB、Redis 等 NoSQL）的分布式事务维持在同一事务语义之中。

# 实现难点

## MVCC 内核

事务隔离级别有两种常见的实现方案，即锁实现和 MVCC 实现。除了 Infomix 等少数数据库，大部分关系型数据库均采用 MVCC 实现。读未提交、读已提交、可重复读和可序列化这 4 种事务隔离级别的标准，是 ANSI 所定义的基于锁实现的方式。事务的并行度随着隔离级别的增加而衰减，除了并发度最低的可序列化，其他隔离级别都伴随着对一致性的权衡和牺牲。下表是基于锁实现的隔离级别对照表。

| 隔离级别 | 脏读   | 不可重复读 | 幻读   |
| :------- | :----- | :--------- | :----- |
| 读未提交 | 可能   | 可能       | 可能   |
| 读已提交 | 不可能 | 可能       | 可能   |
| 可重复读 | 不可能 | 不可能     | 可能   |
| 可序列化 | 不可能 | 不可能     | 不可能 |

通过 MVCC 实现的隔离级别实际上只有 SI（快照隔离）和 SSI（可序列化快照隔离）这 2 种。SI 和 SSI 与 ANSI 的 4 种隔离级别并不能完全对照。其中的读未提交，与读已提交在 MVCC 的实现中性能并无差别，可以忽略不计。因此 SI 可以对应为读已提交和可重复读这 2 种隔离级别。实际上，即使是幻读，在 SI 隔离级别中也是不会出现的。由于快照并发控制并不能真正意义上保证事务是“可串行化”的，所以事务间的并发操作依旧有可能引发数据异常现象。但这里的异常不同于之前提到的脏读、丢失更新的异常，而是一种业务数据间逻辑语义层面的异常，也可以说是由于未能满足数据间的语义约束而产生的异常。这被称之为写偏序（Write skew），它的检测可依据并发事务间读写依赖的多版本可串行化图（The multiversion serialization graph）来实现，即 SSI 隔离级别。下表是基于 MVCC 实现的隔离级别对照表。

| 隔离级别 | 脏读     | 不可重复读 | 幻读     | 写偏序   |
| :------- | :------- | :--------- | :------- | :------- |
| 读未提交 | 无需实现 | 无需实现   | 无需实现 | 无需实现 |
| 读已提交 | 不可能   | 可能       | 可能     | 可能     |
| 可重复读 | 不可能   | 不可能     | 不可能   | 可能     |
| 可序列化 | 不可能   | 不可能     | 不可能   | 不可能   |

自研 MVCC 引擎是 JDTX 的主要难点之一。JDTX 采用与 PostgreSQL 类似的 MVCC 实现方案，通过 xmin 和 xmax 标记事务快照范围，并在 MVCC 引擎中保存每个数据元祖（Tuple）的 xmin 和 xmax 的事务信息。同一数据的多版本以链表的数据结构存储，通过其 xmin 和 xmax 来获取数据的版本在当前事务快照中的可见性。

由于 MySQL 也并未实现 SSI 隔离级别，因此目前的 JDTX 只是实现了 SI 隔离级别，还并未实现 SSI 隔离级别。MVCC 数据的清理（vacuum）是另一技术难点。过长的事务会导致 MVCC 版本过多，导致占用大量存储空间。尤其是 JDTX 是通过内存来存储 MVCC 的活跃数据，因此对内存空间的释放则更加敏感。由于 JDTX 的异步落盘机制，因此除了 MVCC 标准的垃圾回收逻辑之外，判断数据是否落盘成为清理逻辑的额外规则。

## SQL 查询引擎

通过 SQL 查询事务的活跃数据，是 JDTX 的另一个技术实现难点。MVCC 引擎并非关系型数据库，并不能通过识别 SQL 来查询相关数据。JDTX 则通过之前 Apache ShardingSphere 所积累的 SQL 解析模块及其抽象语法树（AST）来实现对 SQL 的理解，以及查询基于内存的 MVCC 引擎中的数据。

对于 SPJ（select-project-join）的 OLTP 类型 SQL，可以从 SQL 的查询结果中获取数据主键。JDTX 将落盘数据从后端数据库中取出作为最终展现数据的基础，并在此之上从 MVCC 引擎中查询出当前事务可见的活跃数据，并对其结果进行归并。换句话说，每次事务内查询都是由落盘数据 + 活跃数据归并而成。归并引擎部分参照了 LSM Tree 的设计思想。

对于非 SPJ 的 OLAP 类型 SQL，JDTX 则采用另外的查询方式。基于聚合函数和分组的 SQL 无法通过主键直接将后端数据库中的落盘数据和 MVCC 引擎中的键值数据直接匹配，因此采用以 MVCC 引擎中数据为主，并将 SQL 改写为剔除活跃数据主键的新 SQL，再从后端数据库中查询无重复的聚合数据进行归并。

# 使用限制

分布式无银弹，这是架构师们对现有的分布式系统比较公认的看法。虽然 JDTX 具备了很多优点，但仍然有一些使用限制。它的使用限制主要有以下 3 点。

- 需要通过 JDTX 访问数据库。JDTX 通过其 MVCC 引擎控制事务的原子性、一致性和隔离性，并通过 WAL 控制事务的持久性。因此在使用 JDTX 的系统中，跨过事务中间件直接查询数据库，是得不到正确的事务数据的，修改数据库则会导致数据紊乱。

- SQL 支持需要持续完善。查询 MVCC 引擎的 SQL 方言兼容则需要持续提升。相对于无损的 ACID 事务原义支持所带来的优势，SQL 兼容度的下降，是 JDTX 带来的权衡。

- 不支持无主键数据。JDTX 需要通过主键来合并 MVCC 引擎和数据库中的数据。因此无法处理没有主键的记录。

# JDTX 与 Apache ShardingSphere

通过 Apache ShardingSphere 提供的 JDBC 接入端，可以使 JDTX 无缝的对接至 Java 应用。除了 JDBC 接入端，Apache ShardingSphere 也提供了基于 MySQL 和 PostgreSQL 的 Proxy 接入端，使 JDTX 像一个单独的数据库一样提供分布式事务的服务。Apache ShardingSphere 将在未来将接入端剥离，使 JDTX 独立使用成为可能。

Apache ShardingSphere 提供了分布式事务的统一 SPI。JDTX 通过实现 ShardingSphere 提供的 SPI，可以很轻松的融入 Apache ShardingSphere 生态。结合 Apache ShardingSphere 与 JDTX，可以将数据分片与分布式事务无缝结合。

独立使用 Apache ShardingSphere 或 JDTX，可以灵活解耦，高度定制，可以看做是基础组件的乐高积木。而将其联合使用，则能够产生化学变化，甚至使它们具备组成分布式数据库基础设施的能力。架设在产品最前端的 Apache ShardingSphere 用于 SQL 解析、数据库协议和数据分片；位于中层的 JDTX 用于通过键值对和 MVCC 的方式处理事务活跃数据；最底层的数据库则仅作为最终的数据存储端。下图是 ShardingSphere + JDTX 的架构图。

![JDTX](https://s2.ax1x.com/2019/10/26/K0vEuj.png)
