# 微服务

微服务（Microservices Architecture Pattern）由 Martin Fowler 在 2014 年提出的，是希望将某个单一的单体应用，转化为多个可以独立运行、独立开发、独立部署、独立维护的服务或者应用的聚合，从而满足业务快速变化及分布式多团队并行开发的需求。如康威定律（Conway’s Law）所言，任何组织在设计一套系统（广义概念）时，所交付的设计方案在结构上都与该组织的通信结构保持一致，微服务与微前端不仅仅是技术架构的变化，还包含了组织方式、沟通方式的变化。

微服务最早可看做 SOA 结构的扩展，与 2000 年代单体化的大服务相反，微服务是代表一组范围狭窄的功能的应用程序。这些应用程序是托管的，可以通过网络使用，并公开定义良好的接口。其他应用程序通过进行“远程过程调用”（RPC）来调用此接口。微服务体系结构的关键特征是代码的托管，调用和部署方式。如果我们考虑大型的整体应用程序，通常将它们分为具有明确定义的接口的封装组件。这些接口将被直接称为进程内接口，而不是通过网络。通过这种方式，我们可以开始将微服务视为具有性能优势（网络 I/O 和序列化/反序列化）的库，以便调用其任何功能。

![典型的微服务之间连接](https://i.postimg.cc/XNmDQrKL/image.png)

微服务与微前端原理和软件工程，面向对象设计中的原理同样相通，都是遵循单一职责(Single Responsibility)、关注分离(Separation of Concerns)、模块化(Modularity)与分而治之(Divide & Conquer)等基本的原则。
对于微服务，不同背景的人也有不同的见解，对于熟悉 SOA 的开发者，微服务也可以认为是去除了 ESB 的 SOA 的一种实现方案；ESB 是 SOA 架构中的中心总线，设计图形应该是星形的，而微服务是去中心化的分布式软件架构。SOA 更多强调重用，而微服务偏向于重写。SOA 偏向水平服务，微服务偏向垂直服务；SOA 偏向自上而下的设计，微服务偏向自下而上的设计。

# 挑战与设计

人月神话一书中提及，没有银弹，意思是只靠一把锤子是盖不起摩天大楼的，要根据业务场景选择设计思路和实现工具。当我们在构建现实中的微服务系统中，其面临的问题又可以细化为服务拆分与服务治理等不同的考虑维度，微服务并不等同于我们选择了 Dubbo 或者 Spring Cloud 等某种微服务解决方案，而是源自内部的业务划分、组织架构。

![Typical MicroService Architecture](https://i.postimg.cc/mkMy155d/image.png)

当我们以这种方式考虑微服务时，我们可能会质疑为什么我们会完全采用微服务架构。答案通常是独立部署和扩展。对于大型的整体应用程序，组织不得不一次部署或释放所有代码。应用程序的每个新版本都可能涉及许多更改。部署变得既危险又费时。任何人都可以使整个系统瘫痪。换句话说，组织为了获得运营利益而采用微服务，而以性能为代价。组织还必须承担维护支持微服务所需的基础架构的成本。事实证明，在许多情况下，这种折衷是有道理的，但它也强烈反对过早采用微服务架构。

微服务的优势可以如下所述：

- 每个服务足够内聚，足够小，代码容易理解、开发效率提高；
- 服务之间可以独立部署，微服务架构让持续部署成为可能；
- 每个服务可以各自进行 x 扩展和 z 扩展，而且，每个服务可以根据自己的需要部署到合适的硬件服务器上；
- 容易扩大开发团队，可以针对每个服务（Service）组建开发团队；
- 提高容错性（Fault Isolation），一个服务的内存泄露并不会让整个系统瘫痪；
- 系统不会被长期限制在某个技术栈上；

但是，随着公司规模的扩大（从 100 名工程师增加到 1000 名工程师），我们开始注意到与系统复杂性大大增加相关的一系列问题。使用微服务架构，人们可以将单个整体的代码库换成黑匣子，黑匣子的功能可以随时更改，并且很容易引起意外行为。

![Uber 复杂微服务联系图](https://s1.ax1x.com/2020/07/25/aSvz0H.png)

其典型的缺点可以如下所示：

- 开发与运维复杂度的增加：开发人员要设计服务之间的通信机制，对于需要多个后端服务的业务场景，要在没有分布式事务的情况下实现代码非常困难；涉及多个服务直接的自动化测试也具备相当的挑战性；
- 真实系统往往难以明确划分边界：在生产环境中要管理多个不同的服务的实例，这意味着开发团队需要全局统筹；
- 状态管理与通信的复杂度；
- 分布式事务与版本管理；

由于服务之间的调用可能会深入很多层，因此了解服务之间的依赖性可能会变得非常困难。第 n 个依赖项中的延迟峰值可能会导致上游问题的级联。如果没有合适的工具，就不可能看到实际发生的事情，从而使调试变得困难。为了构建简单的功能，工程师经常必须跨多个服务工作，所有这些服务都由不同的个人和团队拥有。这就需要大量的协作以及花在会议，设计和代码审查上的时间。当团队在彼此的服务中构建代码，修改彼此的数据模型甚至代表服务所有者执行部署时，先前明确的服务所有权承诺将受到损害。可以形成联网的整体，其中必须将似乎独立的所有服务一起部署以安全地执行任何更改。

# 微服务设计

- API 网关：应用程序接口（APIs），版本（Versioning），契约（Contracts），负载均衡（Load Balancing），路由/适应性路由（Routing/Adaptive Routing）
- 部署与扩展：部署（Deployment），交付（Delivery），数据库的横向扩展，缓存
- 服务拆分与服务发现：服务发现（Service Discovery），健康检查（Health Checking），存活控制（TTL/Deadlining）
- 服务编排与弹性伸缩：伸缩/自动伸缩（Scaling，AutoScaling）
- 统一配置中心：配置（Configuration）
- 统一的日志中心：DaemonSet 部署日志 Agent
- 熔断，限流，降级：断路器（Circuit Breaking），隔水舱（Bulk-heads）
- 全方位的监控：时延追踪（Latency Tracing），分布式服务追踪（Service Causal Tracing），分布式日志（Distributed Logging），运行指标暴露与搜集（Metrics Exposure，Collection）
